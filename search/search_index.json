{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArqonHPO","text":"<p>Adaptive Hyperparameter Optimization for Simulations and ML.</p> <p>ArqonHPO automatically selects the best optimization strategy based on your objective function's landscape:</p> <ul> <li>Smooth, Expensive Simulations? \u2192 Nelder-Mead (fewest evaluations)</li> <li>Noisy, Cheap ML Models? \u2192 TPE (handles variance)</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83e\udd80 Rust Core: High-performance, deterministic engine.</li> <li>\ud83d\udc0d Python Bindings: Simple <code>pip install arqonhpo</code>.</li> <li>\ud83c\udfaf Automatic Mode Selection: Probe, Classify, Refine.</li> <li>\ud83d\udd01 Reproducible: Seed-controlled, artifact-auditable runs.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install arqonhpo\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import json\nfrom arqonhpo import ArqonSolver\n\nconfig = {\n    \"seed\": 42,\n    \"budget\": 100,\n    \"bounds\": {\n        \"learning_rate\": {\"min\": 1e-5, \"max\": 1e-1, \"scale\": \"Log\"},\n        \"batch_size\": {\"min\": 16, \"max\": 256}\n    }\n}\n\nsolver = ArqonSolver(json.dumps(config))\n\nwhile True:\n    batch = solver.ask()\n    if batch is None:\n        break\n\n    results = []\n    for params in batch:\n        loss = my_objective_function(params)\n        results.append({\"params\": params, \"value\": loss, \"cost\": 1.0})\n\n    solver.tell(json.dumps(results))\n</code></pre> <p>Get Started \u2192</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Please see CONTRIBUTING.md for contribution guidelines.</p>"},{"location":"contributing/#license","title":"License","text":"<p>This project is licensed under the MIT License.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please review our CODE_OF_CONDUCT.md.</p>"},{"location":"contributing/#security","title":"Security","text":"<p>Please review our SECURITY.md for reporting vulnerabilities.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Get ArqonHPO running in 5 minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install arqonhpo\n</code></pre>"},{"location":"quickstart/#your-first-optimization","title":"Your First Optimization","text":""},{"location":"quickstart/#1-define-your-objective-function","title":"1. Define your objective function","text":"<pre><code>def objective(params):\n    x = params[\"x\"]\n    y = params[\"y\"]\n    return (x - 2)**2 + (y + 1)**2  # Minimum at (2, -1)\n</code></pre>"},{"location":"quickstart/#2-configure-the-solver","title":"2. Configure the solver","text":"<pre><code>import json\nfrom arqonhpo import ArqonSolver\n\nconfig = {\n    \"seed\": 42,\n    \"budget\": 50,\n    \"bounds\": {\n        \"x\": {\"min\": -10.0, \"max\": 10.0},\n        \"y\": {\"min\": -10.0, \"max\": 10.0}\n    }\n}\n\nsolver = ArqonSolver(json.dumps(config))\n</code></pre>"},{"location":"quickstart/#3-run-the-optimization-loop","title":"3. Run the optimization loop","text":"<pre><code>best_value = float('inf')\nbest_params = None\n\nwhile True:\n    batch = solver.ask()\n    if batch is None:\n        break\n\n    results = []\n    for params in batch:\n        value = objective(params)\n        if value &lt; best_value:\n            best_value = value\n            best_params = params\n        results.append({\n            \"eval_id\": len(results),\n            \"params\": params,\n            \"value\": value,\n            \"cost\": 1.0\n        })\n\n    solver.tell(json.dumps(results))\n\nprint(f\"Best: {best_params} -&gt; {best_value}\")\n# Best: {'x': 2.01, 'y': -0.98} -&gt; 0.0005\n</code></pre>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Cookbook: Sim Tuning - Expensive CFD/Physics simulations</li> <li>Cookbook: ML Tuning - Sklearn/PyTorch hyperparameters</li> <li>Python API Reference</li> </ul>"},{"location":"adrs/001-core-architecture/","title":"ADR-001: Core Architecture","text":"<p>Status: Accepted Date: 2024-12-13</p>"},{"location":"adrs/001-core-architecture/#context","title":"Context","text":"<p>We need an HPO library that:</p> <ol> <li>Automatically selects between optimization strategies.</li> <li>Is deterministic and reproducible.</li> <li>Has a high-performance core with Python bindings.</li> </ol>"},{"location":"adrs/001-core-architecture/#decision","title":"Decision","text":"<p>We implement a Rust Core with PyO3 Bindings architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Python    \u2502\u2500\u2500\u2500\u2500\u25b6\u2502          arqonhpo._internal         \u2502\n\u2502   Client    \u2502     \u2502             (PyO3)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                                     \u2502\n                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                    \u2502          arqonhpo-core              \u2502\n                    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n                    \u2502  \u2502    Solver State Machine     \u2502   \u2502\n                    \u2502  \u2502  Probe\u2192Classify\u2192Refine      \u2502   \u2502\n                    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                    \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n                    \u2502  \u2502       Strategies            \u2502   \u2502\n                    \u2502  \u2502  \u25aa NelderMead (Structured)  \u2502   \u2502\n                    \u2502  \u2502  \u25aa TPE (Chaotic)            \u2502   \u2502\n                    \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n                    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"adrs/001-core-architecture/#key-principles","title":"Key Principles","text":"<ol> <li> <p>Probe-Gated Pipeline: All runs start with a deterministic probe phase. Classification happens after probing, preventing premature strategy commitment.</p> </li> <li> <p>Seed Sovereignty: All randomness flows from explicit seeds. No hidden global RNG.</p> </li> <li> <p>Strategy Trait: Extensible via <code>impl Strategy for YourOptimizer</code>.</p> </li> </ol>"},{"location":"adrs/001-core-architecture/#consequences","title":"Consequences","text":"<ul> <li>Pro: Single codebase for CLI, FFI, and Python.</li> <li>Pro: Deterministic by design.</li> <li>Con: Requires Rust toolchain to build from source.</li> </ul>"},{"location":"adrs/002-python-bridge/","title":"ADR-002: Python Bridge","text":"<p>Status: Accepted Date: 2024-12-13</p>"},{"location":"adrs/002-python-bridge/#context","title":"Context","text":"<p>Python is the dominant language for ML/Data Science. We need first-class Python support.</p>"},{"location":"adrs/002-python-bridge/#decision","title":"Decision","text":"<p>Use PyO3 with Maturin for Python bindings.</p>"},{"location":"adrs/002-python-bridge/#binding-strategy","title":"Binding Strategy","text":"<ol> <li> <p>JSON I/O: Config and results are passed as JSON strings. This avoids complex type mappings and makes the API debuggable.</p> </li> <li> <p>Module Structure: <pre><code>arqonhpo/\n\u251c\u2500\u2500 __init__.py          # Re-exports from _internal\n\u2514\u2500\u2500 _internal.cpython-*.so  # Rust extension\n</code></pre></p> </li> <li> <p>Thread Safety: All traits (<code>Strategy</code>, <code>Probe</code>, <code>Classify</code>) require <code>Send + Sync</code> bounds to satisfy PyO3's GIL requirements.</p> </li> </ol>"},{"location":"adrs/002-python-bridge/#why-json","title":"Why JSON?","text":"<ul> <li>Debugging: Users can <code>print(config_json)</code> to inspect.</li> <li>Serialization: Easy to save/load configs.</li> <li>Simplicity: Avoid PyO3 type conversion complexity.</li> </ul>"},{"location":"adrs/002-python-bridge/#consequences","title":"Consequences","text":"<ul> <li>Pro: Simple, debuggable API.</li> <li>Pro: No pyo3 type mapping bugs.</li> <li>Con: Slight overhead from JSON parsing (negligible vs. objective eval time).</li> </ul>"},{"location":"cookbook/","title":"Cookbook","text":"<p>Real-world recipes for common optimization scenarios.</p>"},{"location":"cookbook/#simulation-tuning","title":"Simulation Tuning","text":"<ul> <li>:material-engine: CFD Parameter Sweep</li> </ul> <p>Tune expensive physics simulations with minimal objective calls.</p>"},{"location":"cookbook/#ml-model-tuning","title":"ML Model Tuning","text":"<ul> <li>:material-brain: Sklearn Hyperparameters</li> </ul> <p>Tune RandomForest, XGBoost, or any sklearn estimator.</p>"},{"location":"cookbook/ml_tuning/","title":"Cookbook: ML Model Tuning (US2)","text":"<p>Tune sklearn or PyTorch hyperparameters with TPE.</p>"},{"location":"cookbook/ml_tuning/#scenario","title":"Scenario","text":"<p>You have an ML training loop that:</p> <ul> <li>Is cheap (seconds per evaluation).</li> <li>Has a noisy landscape (variance from random seeds, data splits).</li> <li>You have a generous budget (e.g., 100-500 runs).</li> </ul> <p>ArqonHPO will detect the noise/variance and use TPE (Tree-structured Parzen Estimator).</p>"},{"location":"cookbook/ml_tuning/#example-sklearn-randomforest","title":"Example: Sklearn RandomForest","text":"<pre><code>import json\nfrom sklearn.datasets import load_iris\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import cross_val_score\nfrom arqonhpo import ArqonSolver\n\n# Data\nX, y = load_iris(return_X_y=True)\n\ndef objective(params):\n    clf = RandomForestClassifier(\n        n_estimators=int(params[\"n_estimators\"]),\n        max_depth=int(params[\"max_depth\"]),\n        random_state=42\n    )\n    # Cross-validation score (higher is better, so negate for minimization)\n    score = cross_val_score(clf, X, y, cv=3).mean()\n    return -score  # Minimize negative accuracy\n\n# Config\nconfig = {\n    \"seed\": 42,\n    \"budget\": 100,\n    \"probe_ratio\": 0.3,  # More probing to detect noise\n    \"bounds\": {\n        \"n_estimators\": {\"min\": 10, \"max\": 200},\n        \"max_depth\": {\"min\": 2, \"max\": 20}\n    }\n}\n\nsolver = ArqonSolver(json.dumps(config))\nbest = {\"value\": float('inf')}\n\nwhile True:\n    batch = solver.ask()\n    if batch is None:\n        break\n\n    results = []\n    for params in batch:\n        loss = objective(params)\n        if loss &lt; best[\"value\"]:\n            best = {\"params\": params, \"value\": loss}\n        results.append({\n            \"eval_id\": 0,\n            \"params\": params,\n            \"value\": loss,\n            \"cost\": 0.5\n        })\n\n    solver.tell(json.dumps(results))\n\nprint(f\"Best: n_estimators={int(best['params']['n_estimators'])}, max_depth={int(best['params']['max_depth'])}\")\nprint(f\"Accuracy: {-best['value']:.4f}\")\n# Best: n_estimators=120, max_depth=8\n# Accuracy: 0.9667\n</code></pre>"},{"location":"cookbook/ml_tuning/#why-tpe","title":"Why TPE?","text":"<p>TPE builds probabilistic models of \"good\" and \"bad\" regions of the hyperparameter space, making it robust to noise and efficient at exploration.</p>"},{"location":"cookbook/sim_tuning/","title":"Cookbook: Simulation Tuning (US1)","text":"<p>Tune expensive, smooth simulation objectives with Nelder-Mead.</p>"},{"location":"cookbook/sim_tuning/#scenario","title":"Scenario","text":"<p>You have a CFD or physics simulation that:</p> <ul> <li>Takes minutes to hours per evaluation.</li> <li>Has a smooth landscape (small parameter changes = small output changes).</li> <li>You have a tight evaluation budget (e.g., 50-100 runs).</li> </ul> <p>ArqonHPO will automatically detect this and use Nelder-Mead, which minimizes evaluations.</p>"},{"location":"cookbook/sim_tuning/#example-cfd-parameter-sweep","title":"Example: CFD Parameter Sweep","text":"<pre><code>import json\nimport time\nfrom arqonhpo import ArqonSolver\n\n# Simulate expensive CFD call\ndef cfd_simulation(params):\n    inlet_velocity = params[\"inlet_velocity\"]\n    turbulence_k = params[\"turbulence_k\"]\n\n    time.sleep(0.5)  # Simulate 30-minute CFD; use 0.5s for demo\n\n    # Fake \"drag coefficient\" as objective\n    drag = (inlet_velocity - 5.0)**2 + (turbulence_k - 0.1)**2\n    return drag\n\n# Config\nconfig = {\n    \"seed\": 123,\n    \"budget\": 30,  # Very tight budget\n    \"probe_ratio\": 0.2,\n    \"bounds\": {\n        \"inlet_velocity\": {\"min\": 1.0, \"max\": 10.0},\n        \"turbulence_k\": {\"min\": 0.01, \"max\": 0.5}\n    }\n}\n\nsolver = ArqonSolver(json.dumps(config))\nbest = {\"value\": float('inf')}\n\nwhile True:\n    batch = solver.ask()\n    if batch is None:\n        break\n\n    results = []\n    for i, params in enumerate(batch):\n        drag = cfd_simulation(params)\n        if drag &lt; best[\"value\"]:\n            best = {\"params\": params, \"value\": drag}\n        results.append({\n            \"eval_id\": i,\n            \"params\": params,\n            \"value\": drag,\n            \"cost\": 30.0  # 30 mins\n        })\n\n    solver.tell(json.dumps(results))\n\nprint(f\"Optimal: {best}\")\n# Optimal: {'params': {'inlet_velocity': 5.02, 'turbulence_k': 0.098}, 'value': 0.0004}\n</code></pre>"},{"location":"cookbook/sim_tuning/#why-nelder-mead","title":"Why Nelder-Mead?","text":"<p>For smooth landscapes, Nelder-Mead's simplex operations converge faster than random search or TPE because it exploits local gradient information without needing derivatives.</p>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>ArqonHPO provides a command-line interface for batch optimization.</p> <p>Under Construction</p> <p>The CLI is planned for a future release. For now, use the Python API.</p>"},{"location":"reference/cli/#planned-usage","title":"Planned Usage","text":"<pre><code>arqonhpo run --config config.json --script ./evaluate.sh\n</code></pre>"},{"location":"reference/cli/#config-file","title":"Config File","text":"<p><code>config.json</code>:</p> <pre><code>{\n  \"seed\": 42,\n  \"budget\": 100,\n  \"bounds\": {\n    \"x\": {\"min\": -5, \"max\": 5}\n  }\n}\n</code></pre>"},{"location":"reference/cli/#evaluation-script","title":"Evaluation Script","text":"<p>The CLI will call your script with parameters as environment variables:</p> <pre><code>#!/bin/bash\n# evaluate.sh\necho \"RESULT=$(python my_simulation.py --x=$ARQON_x)\"\n</code></pre>"},{"location":"reference/python/","title":"Python API Reference","text":"<p>::: arqonhpo</p>"},{"location":"reference/python/#arqonsolver","title":"ArqonSolver","text":"<p>The main entry point for optimization.</p>"},{"location":"reference/python/#constructor","title":"Constructor","text":"<pre><code>ArqonSolver(config_json: str) -&gt; ArqonSolver\n</code></pre> <p>Parameters:</p> <ul> <li><code>config_json</code>: JSON string with solver configuration.</li> </ul> <p>Config Schema:</p> Field Type Required Default Description <code>seed</code> int \u2713 - RNG seed for reproducibility <code>budget</code> int \u2713 - Max number of evaluations <code>bounds</code> dict \u2713 - Parameter bounds (see below) <code>probe_ratio</code> float \u2717 0.2 Fraction of budget for probing <code>strategy_params</code> dict \u2717 null Strategy-specific config <p>Bounds Format:</p> <pre><code>{\n  \"param_name\": {\n    \"min\": 0.0,\n    \"max\": 1.0,\n    \"scale\": \"Linear\"  // or \"Log\"\n  }\n}\n</code></pre>"},{"location":"reference/python/#methods","title":"Methods","text":""},{"location":"reference/python/#ask-listdict-none","title":"<code>ask() -&gt; list[dict] | None</code>","text":"<p>Returns the next batch of candidate parameters, or <code>None</code> if optimization is complete.</p>"},{"location":"reference/python/#tellresults_json-str-none","title":"<code>tell(results_json: str) -&gt; None</code>","text":"<p>Report evaluation results back to the solver.</p> <p>Results Schema:</p> <pre><code>[\n  {\n    \"eval_id\": 0,\n    \"params\": {\"x\": 1.0, \"y\": 2.0},\n    \"value\": 0.5,\n    \"cost\": 1.0\n  }\n]\n</code></pre>"},{"location":"reference/rust/","title":"Rust API Reference","text":"<p>Full API documentation is available via <code>cargo doc</code>.</p> <pre><code>cd ArqonHPO\ncargo doc --open\n</code></pre>"},{"location":"reference/rust/#quick-reference","title":"Quick Reference","text":""},{"location":"reference/rust/#arqonhpo_coremachinesolver","title":"<code>arqonhpo_core::machine::Solver</code>","text":"<p>The core state machine.</p> <pre><code>use arqonhpo_core::machine::Solver;\nuse arqonhpo_core::config::SolverConfig;\n\nlet config: SolverConfig = serde_json::from_str(r#\"...\"#)?;\nlet mut solver = Solver::new(config);\n\nloop {\n    match solver.ask() {\n        Some(candidates) =&gt; {\n            // Evaluate candidates...\n            solver.tell(results);\n        }\n        None =&gt; break,\n    }\n}\n</code></pre>"},{"location":"reference/rust/#arqonhpo_coreconfigsolverconfig","title":"<code>arqonhpo_core::config::SolverConfig</code>","text":"<pre><code>pub struct SolverConfig {\n    pub seed: u64,\n    pub budget: u64,\n    pub bounds: HashMap&lt;String, Domain&gt;,\n    pub probe_ratio: f64,\n    pub strategy_params: Option&lt;HashMap&lt;String, f64&gt;&gt;,\n}\n</code></pre>"},{"location":"reference/rust/#arqonhpo_coreartifactevaltrace","title":"<code>arqonhpo_core::artifact::EvalTrace</code>","text":"<pre><code>pub struct EvalTrace {\n    pub eval_id: u64,\n    pub params: HashMap&lt;String, f64&gt;,\n    pub value: f64,\n    pub cost: f64,\n}\n</code></pre>"}]}